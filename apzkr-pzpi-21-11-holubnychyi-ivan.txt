Міністерство освіти і науки України
Харківський національний університет радіоелектроніки


Факультет комп’ютерних наук


Кафедра програмної інженерії


КУРСОВА РОБОТА
ПОЯСНЮВАЛЬНА ЗАПИСКА
з навчальної дисципліни «Архітектура програмного забезпечення»
Тема роботи: Програмна система організації роботи корпоративних холодильників

Студент гр. ПЗПІ-21-11               __________________ Голубничий І.І.
(підпис)

Керівник роботи                           ________________ доц. Лещинська І.О.
(підпис)
Роботу захищено «__»_________2024 р.
з оцінкою _________________________

Комісія:                                          ______________ доц. Лещинський В.О.
(підпис)
                                                        ________________ доц. Лещинська І.О.
(підпис)
                                                       _______________ ст. викл. Сокорчук І.П.
(підпис)





Харків
2024 р.

Харківський національний університет радіоелектроніки


Факультет комп’ютерних наук	Кафедра програмної інженерії	
Спеціальність 121 – Інженерія програмного забезпечення	
Курс	3	Семестр	6	 Навчальна дисципліна Архітектура програмного забезпечення                            

ЗАВДАННЯ
НА КУРСОВУ РОБОТУ СТУДЕНТОВІ

                                                Голубничому Івану Ігоровичу                                      
1.	Тема роботи: Програмна система організації роботи холодильників	
2.	Термін узгодження завдання курсової роботи «13»       березня 	2024 р.
3.	Термін здачі студентом закінченої роботи «_08_»	 червня      	2024 р.
4.	Вихідні дані до проекту (роботи):  написана пояснювальна записка, реалізована серверна частина, реалізована клієнтська частина, створена Web-частина.                                             
5.	Зміст	пояснювальної записки (перелік питань, що належить розробити) 
вступ, аналіз предметної області, постановка задачі, проектування програмного проекту, структура бази даних, кодування програмного проекту, опис розробленої програмної системи, висновки, перелік посилань, додатки                
6.	Перелік графічного матеріалу (з точним зазначенням обов’язкових креслень)
схема бази даних, діаграма варіантів використання, діаграма розгортання, інтерфейс головної сторінки                                                                                          


 
КАЛЕНДАРНИЙ ПЛАН





№	Основні етапів курсової роботи	Термін виконання
етапів роботи	Примітка
1	 Функціональна специфікація
 програмного проекту	18.03.2024-05.04.2024	
2	 Проектування програмного
 проекту	05.04.2024-10.04.2024	
3	 Кодування програмного проекту	10.04.2024-30.05.2024	
4	 Оформлення пояснювальної
 записки	01.06.2024-08.06.2024	
5	 Захист курсової роботи	08.06.2024-14.06.2024	

Дата видачі завдання «18»            березня	2024 р.


Керівник	 	доц. Лещинська І.О.
(підпис)


Завдання прийняв до виконання
ст.гр. ПЗПІ-21-11
	 		Голубничий І.І.
(підпис)
 
РЕФЕРАТ

Пояснювальна записка до курсової роботи: 58 с., 7 рис., 0 таблиць, 2 додатка, 4 джерела.
АРХІТЕКТУРА, ДАНІ, КЛІЄНТ, УПРАВЛІННЯ, ПРОГРАМА, СИСТЕМА, ХОЛОДИЛЬНИК.
Об’єктом розробки є програмна система організації роботи корпоративних холодильників. Метою роботи є створення комплексної системи, яка дозволяє автоматизувати процеси управління холодильниками, включаючи моніторинг умов зберігання, управління доступом, обробку транзакцій та інтеграцію з іншими бізнес-процесами підприємства. Це повинно забезпечити високий рівень зручності та безпеки для користувачів та адміністрації підприємства.
Методи, застосовані для розробки даної програмної системи, включають використання фреймворку Spring Boot для серверної частини, що забезпечує надійну та безпечну внутрішню інфраструктуру. В якості системи управління базами даних обрано MySQL для ефективного зберігання та управління даними про користувачів, холодильники, моделі, їжу, транзакції та замовлення. 
Результатом виконання роботи стала розробка комплексної системи організації роботи корпоративних холодильників, яка включає серверну частину, компонент Інтернету речей та клієнтські додатки. Система забезпечує централізований моніторинг, віддалене управління, розширені можливості аналітики, високу безпеку даних та інтеграцію з іншими бізнес-процесами підприємства, що сприяє підвищенню ефективності управління холодильниками та оптимізації процесів зберігання харчових продуктів.
 
ЗМІСТ

ВСТУП	6
1 АНАЛІЗ ПРЕДМЕТНОЇ ГАЛУЗІ	8
1.1 Аналіз предметної області	8
1.2  Аналіз існуючих аналогів	9
1.3 Концептуальне моделювання	11
2 ПОСТАНОВКА ЗАДАЧІ	16
2.1 Основний функціонал системи	16
2.2 Рамки первинного випуску	18
2.3 Припущення та залежності	19
2.4 Робоче середовище	21
3 СТРУКТУРА БАЗИ ДАНИХ	23
4 ОПИС РОЗРОБЛЕНОЇ ПРОГРАМНОЇ СИСТЕМИ	26
4.1 Кодування серверної частини	26
4.2 Кодування Web-частини	31
5 ОСОБЛИВОСТІ ЗАСТОСУВАННЯ	34
ВИСНОВКИ	36
ПЕРЕЛІК ДЖЕРЕЛ ПОСИЛАННЯ	38
ДОДАТОК А	39
ДОДАТОК Б	48


 
ВСТУП
	
Програмна система організації роботи корпоративних холодильників вирішує ряд актуальних проблем у сфері зберігання харчових продуктів на підприємствах та сприяє підвищенню ефективності їхньої діяльності. В сучасному світі зростаючий обсяг виробництва та обігу продуктів харчування вимагає від компаній впровадження інноваційних технологій для забезпечення оптимальних умов зберігання та контролю за якістю продукції. Суспільство все більше уваги приділяє якості харчових продуктів та умовам їх зберігання, що робить впровадження подібних систем необхідним для сучасних підприємств.
Завдяки використанню корпоративних холодильників, підприємства можуть забезпечити дотримання всіх необхідних норм та стандартів щодо зберігання харчових продуктів, уникнути втрат через псування товарів та знизити витрати на їх утримання. Програмна система дозволяє автоматизувати процеси моніторингу температури, вологості та інших параметрів, що є критичними для збереження якості продуктів. Це особливо важливо для компаній, які займаються виробництвом, транспортуванням та зберіганням продуктів харчування, оскільки будь-які порушення умов зберігання можуть призвести до значних фінансових втрат та негативних наслідків для здоров’я споживачів.
Запропонована програмна система охоплюватиме широкий спектр функцій та інструментів, які забезпечать автоматизацію управління корпоративними холодильниками. Вона дозволить здійснювати контроль за умовами зберігання в режимі реального часу, вести облік продуктів, що зберігаються, та забезпечувати своєчасне виявлення можливих проблем. Крім того, система надасть можливість аналізу даних та формування звітів, що допоможе в ухваленні обґрунтованих управлінських рішень.
Головна ідея полягає у створенні зручного та ефективного інструменту для автоматизації процесів зберігання харчових продуктів на підприємствах. Мета продукту полягає в забезпеченні високого рівня контролю та управління корпоративними холодильниками, що сприятиме підвищенню якості та безпеки харчових продуктів, а також зниженню витрат на їх зберігання.
Впровадження програмної системи організації роботи корпоративних холодильників також відкриває нові можливості для оптимізації логістичних процесів та зменшення впливу людського фактора на управління запасами. Використання сучасних технологій дозволяє не лише контролювати умови зберігання, але й інтегрувати систему з іншими бізнес-процесами компанії, такими як постачання, виробництво та дистрибуція. Це забезпечує більш точний прогноз потреб у продуктах, своєчасне поповнення запасів та зниження ризиків виникнення дефіциту або надлишків продукції. Завдяки цьому підприємства можуть ефективніше управляти своїми ресурсами, знижувати витрати на логістику та підвищувати загальну конкурентоспроможність на ринку. У кінцевому підсумку, це сприяє створенню більш стійкої та адаптивної системи управління харчовими продуктами, що відповідає сучасним вимогам та викликам індустрії.
Таким чином, впровадження автоматизованої системи організації роботи корпоративних холодильників сприятиме підвищенню ефективності управління підприємствами, забезпечуючи автоматизацію рутинних процесів та покращуючи умови зберігання продуктів. Це не лише підвищує рівень задоволеності споживачів, але й сприяє розвитку індустрії харчових продуктів, роблячи її більш сучасною та технологічною. Автоматизована система забезпечить високий рівень зручності та безпеки як для персоналу підприємств, так і для кінцевих споживачів, створюючи оптимальні умови для зберігання харчових продуктів.
 
1 АНАЛІЗ ПРЕДМЕТНОЇ ГАЛУЗІ
1.1 Аналіз предметної області

Сучасна індустрія зберігання та логістики харчових продуктів постійно розвивається, включаючи впровадження інноваційних систем управління корпоративними холодильниками. Зі зростанням попиту на якісні продукти харчування та дотриманням суворих стандартів безпеки, підприємства стикаються з необхідністю оптимізації процесів зберігання, щоб забезпечити збереження свіжості та якості продукції. В цьому контексті системи управління корпоративними холодильниками стають все більш актуальними.
Основні функції таких систем включають автоматичний контроль температури, вологості, вентиляції та інших критичних параметрів зберігання. Це дозволяє забезпечити стабільні умови, що відповідають нормативним вимогам та рекомендаціям щодо зберігання різних типів харчових продуктів. Важливою складовою є можливість інтеграції системи з іншими внутрішніми процесами підприємства, такими як управління запасами, логістика та дистрибуція. Це забезпечує більш ефективне управління ресурсами, зниження втрат та підвищення загальної ефективності компанії.
Корпоративні холодильники використовуються у різних галузях харчової індустрії, включаючи виробництво, переробку, транспортування та реалізацію продуктів. В умовах високої конкуренції та зростаючих вимог споживачів щодо якості продукції, підприємства прагнуть впроваджувати сучасні технології для підтримання конкурентоспроможності. Використання автоматизованих систем управління холодильниками дозволяє значно знизити вплив людського фактора, мінімізувати ризики помилок та забезпечити високий рівень контролю за умовами зберігання.
З іншого боку, підприємства зацікавлені у підвищенні прозорості та оперативності процесів управління. Це включає можливість дистанційного моніторингу та управління системами, отримання регулярних звітів про стан зберігання продукції та своєчасне виявлення можливих відхилень від нормативних параметрів. Адміністрація підприємств прагне автоматизувати рутинні процеси, зменшити операційні витрати та підвищити продуктивність праці.
Застосування програмних систем для організації роботи корпоративних холодильників також має значний вплив на екологічну складову діяльності підприємств. Оптимізація умов зберігання та управління запасами дозволяє знизити рівень харчових відходів, що є важливим кроком у напрямку сталого розвитку. Зменшення втрат продукції сприяє збереженню ресурсів та зниженню негативного впливу на навколишнє середовище. Крім того, сучасні системи можуть інтегруватися з енергозберігаючими технологіями, що допомагає знизити споживання енергії та скоротити викиди парникових газів. Усі ці фактори сприяють підвищенню екологічної відповідальності підприємств та покращенню їхнього іміджу серед споживачів, які все більше орієнтуються на продукцію з мінімальним екологічним слідом. Таким чином, впровадження програмних систем для управління корпоративними холодильниками не лише підвищує ефективність бізнесу, але й сприяє збереженню навколишнього середовища.
Таким чином, впровадження програмних систем для управління корпоративними холодильниками сприяє підвищенню якості управління, забезпеченню безпеки харчових продуктів та зниженню витрат на їх зберігання. Це дозволяє підприємствам ефективніше відповідати на виклики сучасного ринку, підвищувати рівень задоволеності споживачів та зміцнювати свої позиції в індустрії.

1.2 Аналіз існуючих аналогів

Програмна система організації роботи корпоративних холодильників вирішує багато проблем, пов’язаних зі зберіганням харчових продуктів, підвищенням ефективності управління та зменшенням витрат. На ринку існує кілька аналогічних систем, які також спрямовані на автоматизацію процесів управління холодильними установками. Давайте розглянемо деякі з них.
HACCP - системи призначені для моніторингу критичних контрольних точок у харчовій промисловості. Вони забезпечують автоматичний збір даних про температуру, вологість та інші параметри зберігання продуктів, що дозволяє своєчасно виявляти і усувати можливі порушення. Одним із прикладів є система TempGenius, яка пропонує бездротові рішення для моніторингу умов зберігання. Система дозволяє встановлювати датчики у холодильниках та отримувати дані в режимі реального часу через мобільний додаток або веб-інтерфейс. TempGenius також забезпечує можливість налаштування сповіщень при відхиленні параметрів від норми.
Системи розумного охолодження, такі як Danfoss Smart Store, орієнтовані на оптимізацію енергоспоживання та управління холодильними установками у супермаркетах та великих підприємствах. Danfoss Smart Store використовує алгоритми штучного інтелекту для аналізу даних та оптимізації роботи холодильників, що дозволяє знизити витрати на електроенергію та забезпечити стабільні умови зберігання. Система інтегрується з іншими компонентами інфраструктури, такими як системи вентиляції та опалення, що забезпечує комплексний підхід до управління енергоспоживанням.
Компанія Emerson пропонує широкий спектр рішень для моніторингу та управління холодильними установками. Їхні системи включають датчики, контролери та програмне забезпечення для збору та аналізу даних. Emerson пропонує інтегровані рішення, які забезпечують не тільки контроль температури, але й управління енергоспоживанням, виявлення витоків холодоагенту та автоматичне регулювання роботи обладнання. Система дозволяє користувачам отримувати сповіщення про будь-які відхилення та швидко реагувати на них, що забезпечує високий рівень безпеки та ефективності.
Запропонована програмна система організації роботи корпоративних холодильників має низку переваг порівняно з існуючими аналогами. Вона пропонує більш інтегровані рішення, що охоплюють не тільки моніторинг умов зберігання, але й автоматизацію логістичних процесів та управління запасами. Це дозволяє підприємствам знижувати втрати продукції, оптимізувати ресурси та підвищувати загальну ефективність.
Система використовує інтернет речей (IoT) технології для цілодобового моніторингу параметрів середовища та автоматичного регулювання умов зберігання. Це мінімізує потребу у втручанні персоналу та забезпечує високу точність контролю. Крім того, запропонована система забезпечує можливість дистанційного управління та отримання звітів у режимі реального часу, що підвищує прозорість та оперативність управління.
Таким чином, запропонована програмна система не лише забезпечує високий рівень автоматизації та інтеграції, але й пропонує додаткові функції, які роблять її значно привабливішою для підприємств у порівнянні з існуючими аналогами. Це включає покращений контроль, гнучкість та зручність використання, що сприяє підвищенню якості управління та зберігання харчових продуктів.

1.3 Концептуальне моделювання

Концептуальна модель предметної області будується навколо ідеї створення програмної системи контролю за корпоративними холодильниками. Основне функціональне призначення системи полягає у побудові комунікації між різними видами фізичних пристроїв та автоматизації роботи підприємств, які використовують дану систему.
Предметна область містить три типи користувачів, на яких система має спиратися та реалізовувати свою функціональність залежно від їхніх потреб: клієнти або співробітники певного підприємства, адміністратор бази даних та адміністратор, який відповідає за бізнес-логіку системи. Кожен тип користувача має свій набір чітких функціональних потреб до продукту.
Клієнт або співробітник певного підприємства є основним типом користувача для даної предметної області, який повинен мати доступ до холодильників та можливість зберігати та використовувати їжу для власних потреб. Враховуючи широкий набір розмірів підприємств, які можуть складатися із десятків офісів із різних країн, система повинна мати функціональність для обмеження доступу клієнтів до холодильників та надавати можливість використовувати лише певний набір пристроїв. Клієнт також буде мати потребу перегляду різного виду інформації, такої як: список доступних холодильників, вміст кожного холодильника, перелік власної їжі, яка присутня в системі, історія користувань та список замовлень. Оскільки програмна система повинна мати певні способи монетизації, то клієнт зможе оплатити підписку, щоб отримати доступ до можливості автозамовлення. Описані функціональні потреби повністю характеризують необхідні функції для співробітника підприємства та представлені у вигляді діаграми прецедентів (рис1.1).

 
Рисунок 1.1 – Діаграма прецедентів для клієнтів

Функціональні потреби адміністратора бази даних спираються на можливостях роботи бази даних та забезпечення цілісності даних, щоб керувати інформаційним змістом системи та сприяти її захисту. Адміністратор бази даних має потребу переглядати всю інформацію, яка зберігається в системі про холодильники, користувачів, наявні доступи до холодильників, перелік їжі, автозамовлення та інші сутності, які наявні в системі. Оскільки адміністратор повинен не лише спостерігати за наявними даними, а й працювати з ними, він матиме потребу редагувати, видаляти, додавати різні види інформації. Бази даних зазвичай мають резервні копії, щоб уникнути ризику втрати інформації, тому функції резервного копіювання та відновлення системи після можливої аварії обов’язково мають бути наявні у даного адміністратора. Для візуалізації описаних функцій адміністратора бази даних було створено діаграму прецедентів для даного типу користувачів (рис. 1.2).

 
Рисунок 1.2 - Діаграма прецедентів для адміністратора бази даних

Останній вид користувачів – це адміністратори бізнес-логіки програмної системи. Функціональні потреби цих адміністраторів спираються на контроль різних видів інформації та формування статистик щодо роботи програмної системи загалом. Оскільки підприємства зазвичай мають велику кількість холодильників, виникає потреба у функціях формування статистик щодо витрат електроенергії кожного холодильника в певному підприємстві, а також загальної суми витрат на основі ціни електроенергії. Ці компоненти дозволяють адміністраторам ефективно взаємодіяти з програмною системою, надаючи їм засоби для моніторингу, аналізу та управління всіма аспектами роботи системи контролю за корпоративними холодильниками. Всі функціональні потреби для даного користувача були представлені у вигляді діаграми прецедентів (рис 1.3).

 
Рисунок 1.3 - Діаграма прецедентів для адміністратора бізнес-логіки

Система повинна надавати можливості реєстрації та автентифікації, оскільки дана функціональність є характерною для всіх видів користувачів. Було прийняте рішення виділити даний функціонал на окремій діаграмі прецедентів (рис 1.4).

 
Рисунок 1.4 - Діаграма прецедентів для неавторизованих користувачів

Під час моделювання предметної області було виділено основні види користувачів для даної програмної системи та їхній функціонал, який був описаний та представлений у вигляді діаграм прецедентів. Це дозволяє чітко окреслити завдання та можливості системи для кожного типу користувачів, створюючи структуроване бачення функціональності програмної системи контролю за корпоративними холодильниками. Такий підхід забезпечує ефективну організацію процесів зберігання та управління харчовими продуктами на підприємствах, підвищуючи загальну ефективність та надійність роботи системи.
 
2 ПОСТАНОВКА ЗАДАЧІ
2.1 Основний функціонал системи

Основний функціонал системи включає в себе широкий спектр можливостей для забезпечення ефективного управління корпоративними холодильниками. Виділимо основну функціональність даної системи:
–	контроль температури, вологості та інших параметрів: Автоматичний моніторинг та підтримка оптимальних умов зберігання продуктів у холодильниках. Система збирає дані з датчиків та регулює параметри для забезпечення стабільних умов зберігання, що мінімізує ризик псування продуктів.
–	інтеграція з іншими системами підприємства: Система інтегрується з ERP-системами, системами управління запасами та іншими внутрішніми процесами підприємства, забезпечуючи комплексний підхід до управління ресурсами та дозволяючи автоматизувати процеси поповнення запасів.
–	відеоспостереження та дистанційний моніторинг: Забезпечення можливості відеоспостереження за станом холодильників та віддаленого моніторингу через веб-інтерфейс або мобільний додаток. Це дозволяє відповідальним особам оперативно реагувати на будь-які зміни або проблеми.
–	сповіщення та алерти: Система надсилає сповіщення про будь-які відхилення від встановлених параметрів (наприклад, підвищення температури, вологості, витоки холодоагенту) через SMS, електронну пошту або мобільний додаток, забезпечуючи своєчасне реагування на потенційні проблеми.
–	управління доступом: Система забезпечує різні рівні доступу для користувачів. Клієнти або співробітники підприємства мають обмежений доступ до інформації про холодильники, тоді як адміністратори можуть повністю керувати системою, включаючи управління доступом та налаштуванням параметрів.
–	аналітичний інструмент: Система аналізує дані про використання холодильників, зокрема, споживання електроенергії, частоту відкриття дверей, температурні коливання. На основі цього аналізу система надає звіти та рекомендації для оптимізації роботи холодильників.
–	автоматизація процесів: Включення функцій автоматичного замовлення продуктів при досягненні критичного рівня запасів. Це допомагає уникнути дефіциту продуктів та забезпечити їх своєчасне поповнення, підвищуючи ефективність управління запасами.
–	резервне копіювання та відновлення: Система автоматично створює резервні копії бази даних та надає можливість відновлення системи після аварій або збоїв, що забезпечує безперервність роботи та захист даних.
–	мобільний додаток: Розробка мобільного додатку для зручного доступу до системи з будь-якого місця. Користувачі можуть переглядати стан холодильників, отримувати сповіщення та управляти налаштуваннями через свої мобільні пристрої.
–	локалізація: Система підтримує різні мови для користувачів з різних країн, забезпечуючи локалізацію для України та міжнародну англійську локалізацію, що робить систему доступною для широкого кола користувачів.
–	безпека даних: Забезпечення захисту даних від несанкціонованого доступу. Використання сучасних методів шифрування та автентифікації для захисту інформації, що зберігається та передається.
–	зворотній зв’язок: Користувачі можуть надавати зворотний зв’язок та отримувати підтримку від адміністрації через систему, що допомагає оперативно вирішувати виникаючі питання та покращувати роботу системи.
Таким чином, основний функціонал системи контролю за корпоративними холодильниками охоплює всі необхідні аспекти для ефективного управління умовами зберігання харчових продуктів, забезпечення безпеки даних та зручності користувачів.

2.2 Рамки первинного випуску

Для кращого розуміння функціональності системи контролю за корпоративними холодильниками у першому випуску програмного продукту, поділимо функції на частини, включаючи серверну частину, частину IoT, веб-частину та мобільний додаток.
Серверна частина є ядром системи, яка забезпечує наступні ключові функції:
–	 автентифікація та авторизація: Серверна частина реалізує систему автентифікації користувачів, що дозволяє користувачам входити в систему, та авторизацію на основі ролей, забезпечуючи різний рівень доступу для різних користувачів.
–	 збереження даних: Сервер відповідає за безпечне зберігання всіх даних системи, включаючи інформацію про користувачів, холодильники, запаси, історію використання та інші важливі дані.
–	 підтвердження оплати: Серверна частина інтегрує платіжні системи, такі як Stripe API, для обробки онлайн-платежів, керування підписками та ініціалізації оплат.
–	 захист даних: Сервер забезпечує шифрування всіх важливих даних для захисту від несанкціонованого доступу та здійснює дешифрування на вимогу.
–	 статистика: Сервер формує звіти та статистику щодо використання холодильників, витрат електроенергії, споживання продуктів та інших параметрів, допомагаючи адміністраторам приймати обґрунтовані рішення.
–	 автоматичне формування замовлень: Сервер автоматично генерує замовлення на поповнення запасів, коли рівень продуктів досягає критичного рівня, що допомагає уникнути дефіциту.
–	 адміністрування: Сервер враховує наявність ролей з різним рівнем доступу до даних, дозволяючи адміністраторам керувати системою та виконувати необхідні дії.
Веб-частина системи забезпечує інтерфейс для взаємодії користувачів із системою:
–	 графічний інтерфейс для авторизації та реєстрації: Веб-інтерфейс надає користувачам можливість реєструвати облікові записи та входити в систему за допомогою зручного графічного інтерфейсу.
–	 різні інтерфейси для різних користувачів: Адміністратори та звичайні користувачі мають різні інтерфейси, що забезпечують доступ до необхідних функцій залежно від ролі користувача.
–	 локалізація: Веб-інтерфейс підтримує різні мови, що дозволяє користувачам з різних країн використовувати систему зручно та зрозуміло.
–	 перегляд статистики та історії: Адміністратори можуть переглядати детальну статистику використання холодильників, а користувачі - свою історію використання, доступні холодильники та іншу необхідну інформацію.
–	 оплата онлайн: Веб-інтерфейс забезпечує можливість здійснювати онлайн-платежі за послуги та підписки, використовуючи дані кредитної картки.
–	 налаштування особистого кабінету: Користувачі можуть змінювати свої персональні дані та налаштування профілю через веб-інтерфейс.
–	 доступ до інформації про холодильники: Веб-інтерфейс надає можливість перегляду даних про доступні холодильники, їх стан та історію використання.
–	 контроль параметрів холодильників: Користувачі можуть змінювати певні характеристики холодильників, такі як температура, вологість та інші параметри через веб-інтерфейс.

2.3 Припущення та залежності

–	Сервери мають достатню потужність для обробки потоку користувачів, який може досягати кількох десятків тисяч одночасних підключень.
–	Користувачі матимуть стабільний доступ до інтернету та відповідні пристрої для користування системою, такі як смартфони, планшети чи комп'ютери.
–	Всі холодильники, що використовуються в системі, обладнані необхідними датчиками та пристроями для моніторингу та управління параметрами зберігання.
–	Підприємства, що використовують систему, забезпечують належне технічне обслуговування холодильників та регулярну перевірку стану обладнання.
–	Користувачі дотримуються правил та інструкцій, наданих для користування системою, включаючи процедури реєстрації, автентифікації та управління запасами.
–	Система інтегрована з платіжними системами для забезпечення безперебійної обробки платежів за підписки та послуги.
–	Всі дані, що передаються між компонентами системи, захищені сучасними методами шифрування для забезпечення безпеки та конфіденційності.
Залежності, що виникають під час використовування ПС:
–	Кількість користувачів системи прямо пропорційно залежить від розміру компаній та кількості їхніх співробітників, які придбали систему.
–	Доступ до функцій управління холодильниками залежить від прав доступу користувача, які визначаються на основі ролей (наприклад, адміністратор, звичайний користувач).
–	Температурний режим і інші параметри холодильників залежать від налаштувань, заданих користувачами або адміністраторами через систему.
–	Ефективність моніторингу та управління запасами залежить від точності та регулярності передачі даних з датчиків холодильників до серверної частини системи.
–	Проведення інвентаризації залежить від статистики використання холодильників, включаючи дані про початок та кінець часу користування, частоту відкриття дверей та споживання продуктів.
–	Надійність системи залежить від стабільності інтернет-з’єднання, оскільки більшість функцій потребує онлайн-доступу для синхронізації даних та управління пристроями.
–	Здатність системи надавати своєчасні сповіщення та алерти залежить від швидкості обробки даних сервером та коректності налаштувань сповіщень.
–	Інтеграція з зовнішніми API, такими як платіжні та логістичні сервіси, залежить від доступності та стабільності цих сервісів.
–	Ці припущення та залежності є критичними для успішного функціонування системи контролю за корпоративними холодильниками, забезпечуючи безперебійний доступ до необхідних даних та функцій для всіх користувачів системи.

2.4 Робоче середовище
Серверна частина отримує дані із бази даних та використовує різні зовнішні API для реалізації необхідних функцій системи. На цьому рівні відбувається зв’язок із зовнішніми API, такими як Stripe API та Delivety API. Stripe API дозволяє компаніям приймати онлайн-платежі та керувати платіжними операціями через Інтернет. Delivety API дозволяє формувати замовлення та надсилати їх до служби Delivety для подальшого опрацювання.
Клієнтська частина отримує дані та використовує функції, які надають контролери серверної частини для взаємодії з системою. Окрім взаємодії основних компонентів програмної системи, клієнтська частина містить залежності між внутрішніми компонентами клієнтської сторони. Логіка роботи із даними та їх зберігання потребує використання директорії "Utils", яка надає базові можливості для валідації та зберігання даних.Клієнтська частина системи буде розроблена з використанням JavaScript, HTML та CSS для створення користувацького інтерфейсу. Використання фреймворку React дозволить покращити роботу з інтерфейсом, забезпечуючи високу продуктивність та зручність розробки. Веб-компоненти для React додатка включатимуть головний компонент App, який функціонує як контейнер для всього додатка, визначаючи загальну структуру та маршрутизацію. Це спрощує взаємодію з різними частинами системи, дозволяючи прив’язувати певний функціонал до всіх складових компонентів. Для розробки веб-частини буде використовуватися середовище Visual Studio Code.
 
3 СТРУКТУРА БАЗИ ДАНИХ

Спираючись на моделювання предметної області була побудована ER-діаграма бази даних, яка враховує зберігання інформації для всієї представленої функціональності. Спочатку було виділено основні стрижневі сутності, а саме: користувачі, холодильники, моделі, їжа, транзакції та замовлення. Потім, для уникнення зв’язків багато до багатьох, були створені проміжні та додаткові сутності для повноцінного охоплення бізнес-логіки програми. Зокрема, було додано сутності такі як підписка, доступ, офіс, продукт. Було визначено переліки атрибутів, що повинні мати сутності:
–	користувач: користувач_id, ім’я, прізвище, по-батькові, пароль, електрона пошта, номер телефону, фото, номер трудового договору, тип. Первинний ключ: користувач _id; 
–	холодильник: холодильник_id, температура, вологість. Первинний ключ: холодильник _id; 
–	модель: модель_id, назва моделі, бренд, кількість відділень, споживання електроенергії за рік. Первинний ключ: модель _id; 
–	офіс: офіс_ id, країна, місто, район, вулиця, номер будинку, назва компанії. Первинний ключ: офіс _id; 
–	доступ: доступ_id. Первинний ключ: доступ _id; 
–	підписка: підписка_id, дата початку, дата кінця, ціна. Первинний ключ: підписка _id; 
–	їжа: їжа_id, дата придатності, кількість зайнятих відділень, назва. Первинний ключ: їжа _id; 
–	транзакція: транзакція_id, дата початку, дата кінця. Первинний ключ: транзакція _id; 
–	продукт: продукт_id, назва, вага. Первинний ключ: продукт_id;  
–	замовлення: замовлення_id, дата замовлення, кількість. Первинний ключ: замовлення_id. 
Після виділення атрибутів для сутностей були позначенні зв’язки між ними враховуючи функціональні потреби користувачів системи: 
–	"користувач - підписка" - він має тип зв’язку “один до багатьох”, оскільки користувач повинен придбати нову підписку після закінчення терміну старої; 
–	"користувач - доступ" - він має тип зв’язку “один до багатьох”, оскільки користувач може мати доступ до кількох холодильників; 
–	"офіс - холодильник" - він має тип зв’язку “один до багатьох”, оскільки офіс може мати декілька холодильників; 
–	"модель - холодильник" - він має тип зв’язку “один до багатьох”, оскільки підприємство може мати багато холодильників однієї моделі;  
–	"холодильник - доступ" - він має тип зв’язку “один до багатьох”, оскільки до холодильника можуть мати доступ багато користувачів; 
–	"доступ - транзакція" - він має тип зв’язку “один до багатьох”, оскільки без доступу користувач не здійснить транзакцію та по одному доступу можуть проводитися декілька транзакцій; 
–	"транзакція - їжа" - він має тип зв’язку “один до багатьох”, оскільки за одну транзакцію можуть покласти чи забрати багато їжі; 
–	"доступ - замовлення" - він має тип зв’язку “один до багатьох”, оскільки одним доступом може бути створено багато замовлень. Замовлення має мати доступ, оскільки там міститься інформація про користувача та холодильник; 
–	"продукт - замовлення" - він має тип зв’язку “один до багатьох”, оскільки замовлення може складатися із декількох продуктів
Після визначення сутностей, атрибутів та зв’язків між ними, була розроблена ER-діаграма реляційної бази даних (див. рис. 3.1).
 
Рисунок 3.1 – ER-діаграма для предметної області «Програмна системи організації роботи корпоративних холодильників»
 

4 ОПИС РОЗРОБЛЕНОЇ ПРОГРАМНОЇ СИСТЕМИ
4.1 Кодування серверної частини

 Програмна система призначена для моніторингу та керування корпоративними холодильниками. Вона базується на архітектурі, яка використовує Spring Boot як бекенд фреймворк та REST API для комунікації між компонентами. Оскільки серверна частина використовує стандарт архітектури веб-служб такий як REST API, то взаємодія з ресурсами здійснюється за допомогою стандартних HTTP-методів. Кожен запит включає всю інформацію, необхідну для обробки запиту. Сервер не зберігає інформацію про стан клієнта між запитами. Ресурси, які маю передаватися між різними частинами програмної системи знаходяться у форматі JSON. Використання REST API дозволяє побудувати програмні системи, які є простими, легкими для розуміння та масштабованими. Для кращого розуміння структури серверної частини та її взаємодії із іншими компонентами системи була побудована діаграма пакетів (рис 4.1).

 
Рисунок 4.1 - Діаграма пакетів
Оскільки функціональність програмної системи вимагає сховище для збереження даних, які стосуються користувачів, холодильників, їжі, транзакцій, то було прийняте рішення використовувати базу даних та систему управління таку як MySQL. Згідно архітектурного плану дана база даних має знаходитися на окремому сервері для збереження місця на серверній частині.
Спираючись на широку практику побудови серверних частин, яка полягає у розбитті програми на кілька блоків, які відповідають за свою логіку, то розроблена серверна частина також містить декілька компонентів: контролери, сервіси, репозиторії, безпека, моделі та певна структура тестів.
Контролери обробляють HTTP-запити від клієнтських частин, визначаючи шляхи та викликаючи відповідні сервіси для обробки запитів. Вони надають точку доступу для взаємодії із системою та містять доступ до основної функціональності системи, яка була реалізована.
Сервіси містять бізнес-логіку системи. Вони виконують обчислення, валідацію та взаємодію з базою даних через репозиторії, обробляючи запити від контролерів. Саме на цьому рівні відбувається зв’язок із зовнішніми API, такі як: Stripe API та Delivety API. Stripe API - це програмний інтерфейс, який надається компанією Stripe для взаємодії з їх платіжною системою. Stripe є платіжною платформою, яка дозволяє компаніям приймати онлайн-платежі та керувати платіжними операціями через Інтернет. Delivety API – це також програмний інтерфейс, який дозволяє формувати замовлення та надсилати в службу Delivety для подальшого опрацювання.
Репозиторії взаємодіють з базою даних та моделями, забезпечуючи доступ до даних та виконуючи операції, які пов’язані із видаленням, редагуванням, додаванням та зберіганням даних. Окрім стандартних методів репозиторію були створені додаткові запити, які формують спеціальний набір інформації для певного виду користувачів. Також додаткові методи для формування статистик. Для зменшення ризику виникнення помилок в частині, яка стосується роботи із базою даних були використані технології Java Persistence API (JPA) та Hibernate. Це технології , які використовуються для роботи з реляційними базами даних в Java-додатках. JPA є специфікацією для управління об'єктно-реляційною моделлю даних. Вона надає стандартний спосіб мапити Java-об'єкти на таблиці бази даних і навпаки. Hibernate є конкретною реалізацією специфікації JPA, також він є потужним фреймворком Object-Relational Mapping (ORM), який надає додаткові можливості порівняно з базовою специфікацією JPA.
Моделі містять перелік об’єктів, які мають поля та методи для роботи із сутностями із бази даних, а також об’єкти для надсилання даних між частинами програмної системи. Для візуалізації логіки роботи програмної системи та її компонентів була розроблена діаграма розгортання, яка містить основні технології та принцип роботи системи (рис 4.2). 

 
Рисунок 4.2 - Діаграма розгортання

Існує пакетний шлях, який відповідає за безпеку самого серверу. Механізми безпеки, такі як Spring Security, забезпечують автентифікацію та авторизацію користувачів. Дана частина містить файли конфігурації, які дозволяють правильно налаштувати роботу та перелік фільтрів, які забезпечують доступ користувачів лише до певних контролерів.
Тестування проводилося в окремій файловій структурі, яка спеціально адаптована для написання тестових випадків. Для кожної частини були написані модульні тести та функціональні тести. Модульні тести проводилися за допомогою JUnit. Функціональне тестування проводилося шляхом надсилання в контролери тестові дані, а також із повним запуском програми для симуляції робочого процесу.
Оскільки сервіси реалізовують основну бізнес-логіку системи, то функції, які наявні на серверній частині описуються на рівні сервісів. В сервісах наявний клас «AuthenticationServiceImpl», який реалізує інтерфейс «AuthenticationService». Він відповідає за реалізацію функцій авторизації та автентифікації, яка працює на основі токенів, які мають свій певний час дії та дозволяють серверу визначати користувача, який хоче отримати доступ до функції. Головна логіка полягає в тому, що спочатку перевіряється наявність в системі даного користувача, потім створюють токени, які відправляють на клієнтську частину. Метод, який відповідає за автентифікації називається «signIn()» (див. додаток А, пункт А.1), який приймає пароль та пошту, а надсилає створені токени.
Клас «AdminServiceImpl», який реалізує інтерфейс «AdminService». Даний клас містить функції, які стосуються адміністрування системи, а саме функції редагування, видалення, додавання та перегляду інформації до бази даних.     Окрім     стандартних     операцій,	наявні     також     функції
«getSpendingElectricity()» та «getSumSpending()» (див. додаток А, пункт А.2), які відповідають за статистику, яка присутня в системі. Функції резервного копіювання та відновлення бази даних також присутні та мають відповідні назви «doBackupDatabase()» (див. додаток А, пункт А.3), який приймає зашифрований шлях для резервації та метод «restoreDatabase()» (див. додаток А, пункт А.4), який приймає закодований шлях знаходження резервної копії. Щоб покращити якість коду було створено клас «DatabaseManager» (див. додаток А, пункт А.5), який приховує логіку активації команди резервного копіювання та відновлення. Клас «CustomUserDetailsService», який реалізує вбудований інтерфейс «UserDetailsService», містить метод «loadUserByUsername» (див. додаток А, пункт А.6), що відповідає за логіку отримання із репозиторію інформацію про користувача за електронною поштою. Потім метод збирає лише інформації про пароль, логін та тип користувача, щоб передати класам конфігурації та фільтрам системи безпеки з метою контролю дій користувача та запобігання отримання доступу до заборонених адрес контролерів.
Клас «FridgeServiceImpl», який реалізує інтерфейс «FridgeService», містить методи, які реалізовують необхідну бізнес-логіку роботи холодильників. Перший метод називається «checkUserById()» (див. додаток А, пункт А.7), він приймає ідентифікатори користувача та холодильника, а потім перевіряє чи є доступ користувача до даного пристрою, якщо все пройшло успішно, то повертає дані про користувача. Наступні методи містять пряму роботу із репозиторіями, а саме надаються можливості отримання історії користувань, даних про холодильник, редагування інформації, отримання списку продуктів, наявних в холодильнику
Метод «getAutoOrdersById()» (див. додаток А, пункт А.8) приймає параметри ідентифікатора холодильника та користувача, потім перевіряє наявність актуальної підписки та надає дані про заплановані автозамовлення. Важливим методом для системи є «doInventoryForFridge()» (див. додаток А, пункт А.9), який приймає ідентифікатор холодильника та проводить інвентаризацію для певного холодильника. Основна робота методу полягає в тому, що система формує список з продуктів в даному холодильнику, які вже вичерпали свій термін придатності, потім для кожного продукту визначається користувач, який поклав його. Згідно електронної пошти користувача, система надсилає на пошту повідомлення, яке було завчасно сформовано. Щоб приховати логіку надсилання повідомлення було створено клас «EmailSender» (див. додаток А, пункт А.10), який надає методи надсилання. Метод «doAutoOrdering()» (див. додаток А, пункт А.11) приймає ідентифікатор холодильника та проводить перегляд списку для автозамовлення. Якщо список містить дати, які стосуються поточного дня, то метод формує об’єкт для передачі даних, а також створює клас «Delivety» (див. додаток А, пункт А.12), який містить логіку формування запитів для зовнішнього API. Після повернення відповіді, що все було успішно замовлено, система видаляє цей продукт із списку автозамовленя.
Клас «StripeServiceImpl», який реалізує інтерфейс «StripeService», має метод «createPaymentIntent()» (див. додаток А, пункт А.13), який формує новий платіжний переказ та направляє його на платформу Stripe. Дана функція була реалізована на серверній частині, оскільки секретні ключі, які використовуються для створення сплати, мають зберігатися в безпечному місці.
Клас «UserServiceImpl», який реалізує інтерфейс «UserService», має важливі методи для клієнта, як типу користувача. Він містить метод «getFridgesByUserEmail()» (див. додаток А, пункт А.14), який дозволяє передати список холодильників, які доступні для певного користувача. Метод «getAllFoodUserByEmail()» (див. додаток А, пункт А.14) надає список їжі, яку має користувач на даний момент. Також містить методи, які напряму отримують, додають, видаляють, редагують інформацію із бази даних. Метод «getAllOrdersForUserByEmail()» (див. додаток А, пункт А.15) повертає список автозамовлення, якщо користувач має актуальну підписку. Наступні методи «getUserPhoto()» (див. додаток А, пункт А.16) та «saveUser()» (див. додаток А, пункт А.16) використовують клас «PhotoParser» (див. додаток А, пункт А.17), який зберігає фото та розміщує її адрес в базі даних. Метод «saveUser()» також зашифровує пароль, щоб в базі даних зберігався хеш. Також міститься метод «hasActualSubscription» (див. додаток А, пункт А.18) який повертає логічне значення, що дає змогу зрозуміти наявність актуальної підписки у користувача.

4.2 Кодування Web-частини

Коли користувач виявляє бажання увійти або зареєструватися в систему, то програма має певну систему валідації даних, які містяться у файлах «Validating» та «RegisterValidation» (див. додаток Б, пункт Б.1), які реалізовують логіку перевірки даних перед відправкою на серверну частину. Частина програми, яка власне формує HTTP-запит та відправляє в потрібний метод відбувається у файлах «registractionLogic» та «authenticationCheck» (див. додаток Б, пункт Б.2).
Після входження в систему як клієнт, він має змогу переглянути список холодильників, власної їжі, відвідування та автозамовлення. Бізнес-логіка, яка відповідає за відображення списків із даними доволі схожа, тому розглядаючи код файлу «FoodUser» (див. додаток Б, пункт Б.3) можна побачити основний принцип роботи даних списків. Також для покращення роботи програми були використанні функції для взаємодії із React. Хуки (hooks) - це функції, які дозволяють використовувати функціональні можливості React в компонентах. Це новий спосіб організації логіки в компонентах React, що робить їх більш читабельними та перевикористовуваними.
Основний користувач системи має змогу придбати підписку на певний термін, а також оплатити її через Stripe API, тому логіка, яка відповідає за надсилання даних до системи оплати міститься у файлі «checkoutPayment» (див. додаток Б, пункт Б.4). 
Логіка додавання продуктів для автозамовлення знаходиться у файлі «autoOrderAdd» (див. додаток Б, пункт Б.5), даний код передбачає додавання багатьох продуктів та одним запитом надсилати їх до серверної частини.
Налаштування містить можливість змінювати персональні дані та локалізувати мову системи для зручнішого використання. Знаходиться логіка зміни персональних даних , а саме процес надсилання даних у файлі «settingsSaver» (див. додаток Б, пункт Б.6).
Для реалізації локалізації даних програми був застосований процес. Internationalization -  це процес розробки та налаштування програмного забезпечення для підтримки багатьох мов. Метою є забезпечення того, що програма може легко адаптуватися до різних мов та культур, що полегшує її використання користувачами з різних частин світу.
У веб-розробці бібліотеки та інструменти для i18n дозволяють системі локалізувати свої веб-сторінки. Це охоплює переклад текстових рядків, форматування чисел та дат, а також інші аспекти, щоб зробити додаток доступним та зрозумілим для різних аудиторій.
Одним з популярних підходів до i18n є використання бібліотек, таких як react-i18next для React-додатків. Ці бібліотеки надають інструменти для динамічного підключення різних мов та управління ресурсами для кожної локальної частини. Зазвичай, вони дозволяють розробникам визначати рядки тексту, які можна локалізувати, та надають механізми для їх перекладу та використання в додатку. Такий підхід сприяє глобалізації додатків та забезпечує вдосконалену взаємодію з різними географічними та культурними групами користувачів.
 
5 ОСОБЛИВОСТІ ЗАСТОСУВАННЯ

Програмна система організації роботи корпоративних холодильників має низку особливостей, які роблять її ефективним інструментом для управління умовами зберігання харчових продуктів у великих компаніях. Розглянемо основні особливості її застосування:
Система автоматизує процеси моніторингу та управління холодильниками, що значно знижує необхідність у ручному контролі. Автоматичний збір даних про температуру, вологість та інші параметри зберігання дозволяє оперативно реагувати на будь-які відхилення від встановлених норм.
Система дозволяє централізовано контролювати умови зберігання у всіх холодильниках компанії, незалежно від їхнього розташування. Це особливо корисно для великих підприємств з численними офісами або виробничими майданчиками у різних регіонах або країнах.
Система інтегрується з ERP-системами, системами управління запасами та іншими бізнес-процесами підприємства. Це забезпечує комплексний підхід до управління ресурсами, що дозволяє автоматизувати поповнення запасів, оптимізувати логістичні процеси та знижувати витрати.
Користувачі можуть віддалено контролювати та керувати параметрами холодильників через веб-інтерфейс або мобільний додаток. Це забезпечує гнучкість та зручність у управлінні, дозволяючи швидко реагувати на зміни незалежно від місця перебування користувача.
Система надає розширені аналітичні інструменти для аналізу ефективності використання холодильників, споживання електроенергії, частоти відкриття дверей та інших параметрів. Це дозволяє приймати обґрунтовані рішення щодо оптимізації роботи обладнання та зниження витрат.
Система забезпечує високий рівень безпеки та захисту даних. Використання сучасних методів шифрування та автентифікації гарантує захист інформації від несанкціонованого доступу. Крім того, передбачено резервне копіювання даних для уникнення втрати інформації у разі збоїв.
Система побудована на модульній архітектурі, що дозволяє легко додавати нові функції та інтегрувати її з іншими компонентами IT-інфраструктури підприємства. Висока масштабованість дозволяє системі рости разом з підприємством, забезпечуючи ефективне управління навіть при збільшенні кількості холодильників та обсягів даних.
Система надає зручні інтерфейси для різних категорій користувачів, включаючи адміністраторів, звичайних співробітників та технічний персонал. Це спрощує навчання та використання системи, забезпечуючи високу продуктивність роботи.
Система підтримує різні мови та враховує локальні особливості, що робить її зручною для використання у міжнародних компаніях з офісами в різних країнах.
Інтеграція з пристроями Інтернету речей (IoT) дозволяє використовувати різноманітні сенсори для моніторингу умов зберігання, забезпечуючи високу точність та надійність даних.
Ці особливості роблять програмну систему організації роботи корпоративних холодильників потужним інструментом для забезпечення ефективного та безпечного зберігання харчових продуктів, підвищення продуктивності роботи та зниження витрат на управління ресурсами. 
ВИСНОВКИ

У ході роботи над проектом розробки програмної системи організації роботи корпоративних холодильників було досягнуто значних результатів у автоматизації та оптимізації процесів управління холодильними установками. Система забезпечує широкий спектр можливостей для моніторингу та контролю умов зберігання харчових продуктів, що є критично важливим для сучасних підприємств, які прагнуть підвищити ефективність та безпеку своєї діяльності.
Розробка серверної частини здійснювалася з використанням фреймворку Spring Boot, що забезпечило надійну основу для створення веб-додатків і мікросервісів. Інтеграція з Stripe API дозволила реалізувати функціонал для обробки онлайн-платежів, що значно спрощує процес управління фінансовими операціями. Використання Hibernate забезпечило ефективну взаємодію з базою даних MySQL, дозволяючи надійно зберігати та управляти всіма необхідними даними.
Було також розроблено клієнтську веб-частину, що базується на фреймворку React. Це дало змогу створити інтуїтивно зрозумілий та зручний для користувачів інтерфейс, що забезпечує доступ до всіх функцій системи. Користувачі можуть віддалено контролювати холодильники, переглядати статистику, отримувати сповіщення про стан холодильників та керувати умовами зберігання через веб-інтерфейс.
Система інтегрується з іншими бізнес-процесами підприємства, що забезпечує комплексний підхід до управління ресурсами. Це дозволяє автоматизувати процеси поповнення запасів, оптимізувати логістичні процеси та знижувати витрати. Високий рівень безпеки даних забезпечується за рахунок використання сучасних методів шифрування та автентифікації, що гарантує захист інформації від несанкціонованого доступу.
Інтеграція з іншими бізнес-процесами підприємства, такими як ERP-системи та системи управління запасами, забезпечує комплексний підхід до управління ресурсами. Це дозволяє автоматизувати процеси поповнення запасів, оптимізувати логістичні процеси та знижувати операційні витрати. Високий рівень безпеки даних забезпечується за рахунок використання сучасних методів шифрування та автентифікації, що гарантує захист інформації від несанкціонованого доступу.
Впровадження системи на підприємстві дозволить підвищити ефективність управління холодильними установками, знизити витрати на зберігання та покращити контроль за умовами зберігання харчових продуктів. Це сприятиме забезпеченню високої якості продукції та задоволенню вимог сучасного ринку.
Підсумовуючи, можна сказати, що розроблена програмна система організації роботи корпоративних холодильників значно підвищує ефективність управління холодильними установками, забезпечуючи автоматизацію моніторингу, контролю умов зберігання та оптимізацію бізнес-процесів підприємства. Це робить систему незамінним інструментом для сучасних підприємств, які прагнуть забезпечити високий рівень якості та безпеки своєї продукції.

 
ПЕРЕЛІК ДЖЕРЕЛ ПОСИЛАННЯ

1.	Abrahamsson P. Agility and architecture: can they coexist? / Ali Babar M., Kruchten P., IEEE Softw 2010. pp.16–22. 
2.	Nord R.L. Software architecture-centric methods and agile development / Tomayko J.E. IEEE Softw 2006. pp.47–53. 
3.	Martin R. Clean architecture: a craftsman's guide to software structure and design. Pearson Education, Limited, 2017.
4.	Martin R. Robert C. martin clean code collection (collection). Pearson Education, Limited.
 
ДОДАТОК А
Функції бізнес-логіки серверної частини



А.1 Функція «signIn»


1	public JwtAuthenticationResponse signIn(SignInRequest signInRequest) {
2	authenticationManager.authenticate(new UsernamePasswordAuthenticationToken(
3	signInRequest.getEmail(),
4	signInRequest.getPassword()) 5	);
6
7	var user = customUserDetailsService.loadUserByUsername(signInRequest.getEmail());
8	var webToken = generationToken(user);
9	var refreshToken = generationRefreshToken(new HashMap<>(), user);
10
11	JwtAuthenticationResponse jwtAuthenticationResponse = new JwtAuthenticationResponse();
12	jwtAuthenticationResponse.setToken(webToken);
13	jwtAuthenticationResponse.setRefreshToken(refreshToken);
14	return jwtAuthenticationResponse; 15	}


А.2 Функції «getSpendingElectricity()» та «getSumSpending()»

1	@Override
2	public List<FridgeSpending> getSpendingElectricity(float price, String nameCompany) {
3	return fridgeRepository.getSpendingMoneyForEveryFridge(price, nameCompany);
4 }
5
6	@Override
7	public float getSumSpending(float price, String nameCompany){
8	return fridgeRepository.getSpendingMoneyAllFridges(price,nameCompany);
9 }
 

А.3 Функція «doBackupDatabase()»

1	@Override
2	public boolean doBackupDatabase(byte[] backupPathHash) {
3	byte[] decodedBytes = Base64.getDecoder().decode(backupPathHash);
4	String backupPathDecoded = new String(decodedBytes, StandardCharsets.UTF_8);
5	DatabaseManager databaseManager = new DatabaseManager();
6	return databaseManager.backupSuccessful(backupPathDecoded); 7 }

А.4 Функція «restoreDatabase()»


1	@Override
2	public boolean restoreDatabase(byte[] backupPathHash) {
3	byte[] decodedBytes = Base64.getDecoder().decode(backupPathHash);
4	String backupPathDecoded = new String(decodedBytes, StandardCharsets.UTF_8);
5	DatabaseManager databaseManager = new DatabaseManager();
6	return databaseManager.restoreSuccessful(backupPathDecoded); 7 }

А.5 Клас «DatabaseManager»


1 public class DatabaseManager { 2
3	/** Uses "mysqldump" command for backup */
4	public boolean backupSuccessful(String backupPath) {
5	ProcessBuilder processBuilder = new ProcessBuilder(
6	"C:\\Program Files\\MySQL\\MySQL Server 8.0\\bin\\mysqldump",
7	"-u", Constants.DATABASE_USERNAME,
8	"-p" + Constants.DATABASE_PASSWORD,
9	"--add-drop-table",
10	"--databases", Constants.DATABASE_URL,
11	"-r", backupPath 12	);
13
14		return createProcessSuccessful(processBuilder); 15	}
16
17	/** Uses "mysql" command for restoring */
18	public boolean restoreSuccessful(String backupPath) {
19	ProcessBuilder processBuilder = new ProcessBuilder(
20	"C:\\Program Files\\MySQL\\MySQL Server 8.0\\bin\\mysql",
 

21		"-u" + Constants.DATABASE_USERNAME,
22		"-p" + Constants.DATABASE_PASSWORD,
23		Constants.DATABASE_URL,
24		"-e", "source " + backupPath
25	);	
26		
27		return createProcessSuccessful(processBuilder); 28	}
29
30	private boolean createProcessSuccessful(ProcessBuilder processBuilder) {
31	try {
32	Process process = processBuilder.start();
33	int processComplete = process.waitFor();
34	return true;
35	} catch (Exception e) {
36	return false; 37	}
38	}
39 }

А.6 Функція «loadUserByUsername»

1	@Override
2	public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
3	User user = userRepository.findUserByEmail(username).orElse(null);
4	if (user == null) {
5	throw new UsernameNotFoundException("User not found with username: " + username);
6	}
7
8	Set<GrantedAuthority> authorities = new HashSet<>();
9	authorities.add(new SimpleGrantedAuthority("ROLE_" + user.getType().toString()));
10
11	return new org.springframework.security.core.userdetails.User(
12			user.getEmail(),
13			user.getHashPassword(),
14			authorities
15		);	
16	}		

А.7 Функція «checkUserById()»

1	@Override
2	public User checkUserById(int fridgeId, int userId) {
 

3	List<Access> accesses = accessRepository.findAllAccessForUserById(userId);
4	User user = userRepository.findById(userId).get(); 5
6	if (userRepository.findById(userId).isPresent() &&
!accesses.isEmpty()) {
7	for	(Access access : accesses) {
8		if (access.getFridge().getFridgeId() == fridgeId &&
9		access.getUser().getUserId() == userId) {
10		return user;
11		}
12	}	
13		}
14		return null;
15	}	

А.8 Функція «getAutoOrdersById()»

1	@Override
2	public List<FridgeOrder> getAutoOrdersById(int fridgeId, String email) {
3	User user = userRepository.findUserByEmail(email).orElse(null); 4
5	if (user != null && 6
!subscriptionRepository.getActualSubscriptionsForUser(user.getUserId()
).isEmpty()) {
7	return
autoOrderRepository.getInfoOrdersForFridgeById(fridgeId);
8		} else {
9		return Collections.emptyList();
10		}
11	}	

А.9 Функція «doInventoryForFridge()»

1	@Override
2	public void doInventoryForFridge(Integer fridgeId) {
3	Fridge fridge = fridgeRepository.findById(fridgeId).get();
4	List<SpoiledFood> spoiledFoodsInFridge = foodRepository.getSpoiledFoodByFridgeId(fridge.getFridgeId());
5	sendEmailEveryOwnerFood(spoiledFoodsInFridge); 6 }
7
8	private void sendEmailEveryOwnerFood(List<SpoiledFood> spoiledFoodsInFridge) {
9	User user;
10	String bodyMessage; 11
12	try {
 

13	for (SpoiledFood spoiledFood : spoiledFoodsInFridge) {
14	user =
userRepository.findById(spoiledFood.getUserAccess()).get();
15	bodyMessage = generateMessageForSpoiledFood(spoiledFood);
16	emailSender.sendEmail(user.getEmail(), bodyMessage);
17		}
18		} catch (Exception e) {
19		System.out.println(e.getMessage());
20		}
21	}	

А.10 Клас «EmailSender»

1 public class EmailSender { 2
3	private static final String SUBJECT = "Program controlling fridges";
4
5	private static final String SMTP_HOST = "smtp.gmail.com"; 6
7	private static final int SMTP_PORT = 587; 8
9	private static final String EMAIL_ADDRESS = "ukrainigromadanin284@gmail.com";
10
11	private static final String EMAIL_PASSWORD = "mmniqeveixmprktj";
12
13	private static final String MAIL_STARTTLS_ENABLE = "true"; 14
15	private final JavaMailSenderImpl javaMailSender = new JavaMailSenderImpl();
16
17	public void sendEmail(String emailTo, String body) throws MessagingException {
18	connectEmailSender(); 19
20	MimeMessage mimeMessage = javaMailSender.createMimeMessage();
21	MimeMessageHelper helper = new MimeMessageHelper(mimeMessage, true);
22
23	helper.setTo(emailTo);
24	helper.setSubject(SUBJECT);
25	helper.setText(body); 26
27		javaMailSender.send(mimeMessage); 28	}
29
30	private void connectEmailSender() {
 

31	javaMailSender.setHost(SMTP_HOST);
32	javaMailSender.setPort(SMTP_PORT);
33	javaMailSender.setUsername(EMAIL_ADDRESS);
34	javaMailSender.setPassword(EMAIL_PASSWORD);
35	Properties props = javaMailSender.getJavaMailProperties();
36	props.put("mail.smtp.starttls.enable", MAIL_STARTTLS_ENABLE);
37	}
38 }

А.11 Метод «doAutoOrdering()»

1	@Override
2	public void doAutoOrdering(int fridgeId) {
3	List<AutoOrder> autoOrdering = autoOrderRepository.findAll();
4	Delivety delivety = new Delivety();
5	boolean isTimeToOrder; 6
7	for (AutoOrder autoOrder : autoOrdering) {
8	isTimeToOrder = autoOrder.getAccess().getFridge().getFridgeId() == fridgeId &&
9
autoOrder.getDateDelivery().isBefore(LocalDateTime.now()) || 10
autoOrder.getDateDelivery().isEqual(LocalDateTime.now()); 11
12	if (isTimeToOrder) {
13	AutoOrderRequest newRequest = new AutoOrderRequest(autoOrder);
14	delivety.sendAutoOrdering(newRequest); 15 autoOrderRepository.deleteById(autoOrder.getOrderId()); 16	}
17	}
18 }

А.12 Клас «Delivety»

1 public class Delivety { 2
3	private final static String DELIVETY_API_URL = "https://smart2.delivety.com/hooks/catch/bx3sl8kl43";
4
5	private final static String ACCESS_TOKEN = "yUk2EzNE3MLzYuyTnEK3N4zc";
6
7	public void sendAutoOrdering(AutoOrderRequest autoOrderRequest) {
8	autoOrderRequest.access_token = ACCESS_TOKEN;
 

9	HttpHeaders headers = new HttpHeaders();
10	headers.setContentType(MediaType.APPLICATION_JSON); 11
12	HttpEntity<AutoOrderRequest> request = new HttpEntity<>(autoOrderRequest, headers);
13
14	RestTemplate restTemplate = new RestTemplate();
15	restTemplate.postForObject(DELIVETY_API_URL, request, String.class);
16	}
17 }

А.13 Функція «createPaymentIntent()»

1	@Override
2	public StripeResponse createPaymentIntent(StripeRequest request)
3		throws StripeException {
4		
5		Customer customer = new Customer();
6		customer.setEmail(request.getEmail());
7		
8		PaymentIntentCreateParams params =
9		PaymentIntentCreateParams.builder()
10		.setAmount(request.getAmount() * PRICE)
11		.setCurrency("usd")
12		.setCustomer(customer.getId())
13		.setAutomaticPaymentMethods(
14		PaymentIntentCreateParams
15		.AutomaticPaymentMethods
16		.builder()
17		.setEnabled(true)
18		.build()
19		)
20		.build();
21		PaymentIntent intent =
22		PaymentIntent.create(params);
23		
24		return new StripeResponse(intent.getId(),
25		intent.getClientSecret());
26	}	

А.14 Функції «getFridgesByUserEmail()» та «getAllFoodUserByEmail()»

1	@Override
2	@Transactional
3	public List<Fridge> getFridgesByUserEmail(String email) {
4	User user = userRepository.findUserByEmail(email).orElse(new User());
5	return fridgeRepository.getFridgesByUserId(user.getUserId()).get();
 

6 }
7
8	@Override
9	public List<UserFood> getAllFoodUserByEmail(String email) {
10	User user = userRepository.findUserByEmail(email).orElse(new User());
11	return foodRepository.getAllFoodUserById(user.getUserId()); 12 }

А.15 Функції «getAllOrdersForUserByEmail()»

1	@Override
2	public List<UserOrder> getAllOrdersForUserByEmail(String email) {
3	User user = userRepository.findUserByEmail(email).orElse(new User());
4	List<Subscription> presentSubscription = subscriptionRepository.getActualSubscriptionsForUser(user.getUserId())
;
5	if (!presentSubscription.isEmpty()) {
6	return
autoOrderRepository.getAllOrdersForUserById(user.getUserId());
7		} else {
8		return null;
9		}
10	}	

А.16 Функції «getUserPhoto()» та «saveUser()»

1	public byte[] getUserPhoto(String email) {
2	String photoPath = userRepository.findUserByEmail(email).orElse(new User()).getPhoto();
3	return PhotoParser.pullPhoto(photoPath); 4 }
5
6	@Override
7	public void saveUser(User user, MultipartFile file) {
8	BCryptPasswordEncoder passwordEncoder = new BCryptPasswordEncoder();
9
user.setHashPassword(passwordEncoder.encode(user.getHashPassword())); 10
11	PhotoParser photoParser = new PhotoParser(file);
12	photoParser.savePhoto(); 13
14	user.setPhoto(photoParser.getAbsolutePath());
15	userRepository.save(user); 16 }
 

А.17 Функції «getUserPhoto()» та «saveUser()»

1 public class PhotoParser { 2
3	private static final String UPLOAD_PATH = "/fridges/img"; 4
5	private final MultipartFile file; 6
7	private String absolutePath; 8
9	public PhotoParser(MultipartFile multipartFile) {
10		this.file = multipartFile; 11	}
12
13	public void savePhoto() {
14	if (file == null || file.isEmpty() || file.getOriginalFilename() == null) return;
15	try {
16	String folderPath = System.getProperty(UPLOAD_PATH);
17	File destination = new File(folderPath, Objects.requireNonNull(file.getOriginalFilename()));
18	FileCopyUtils.copy(file.getBytes(), destination);
19	absolutePath = destination.getAbsolutePath();
20		} catch (IOException e) {
21		e.printStackTrace();
22		}
23	}	
24		
25		public String getAbsolutePath() {
26		if (absolutePath != null) {
27		return absolutePath;
28		}
29		return "";
30		}
31		
32		public static byte[] pullPhoto(String photoPath){
33		if (photoPath != null) {
34		try {
35		Path path = Paths.get(photoPath);
36		return Files.readAllBytes(path);
37		} catch (IOException e) {
38		e.printStackTrace();
39		}
40		}
41		return null;
42		}
43	}	
 
ДОДАТОК Б
Основні функції клієнтської частини


Б.1 Функції авторизації та реєстрації


1	export function validateForm() {
2		let password = document.getElementById("password").value;
3		let email = document.getElementById("username").value;
4
5	if (password.length > 16) {
6	alert("Пароль не може бути більше 16 символів");
7	return false; 8	}
9
10	const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
11	if (!emailRegex.test(email)) {
12	alert("Невірний формат електронної пошти");
13	return false; 14	}
15
16		return true; 17	}
18	export function validateFormRegister() {
19	let firstPassword = document.getElementById("password_r").value;
20	let secondPassword = document.getElementById("passwordAgain_r").value;
21	let name = document.getElementById("name_r").value;
22	let surname = document.getElementById("surname_r").value;
23	let fatherName = document.getElementById("fatherName_r").value;
24	let numberContract = document.getElementById("numberContract_r").value;
25	let email = document.getElementById("username_r").value;
26	const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/; 27
28	if (firstPassword !== secondPassword) {
29	alert("Не правильно введені паролі");
30	return false;
31	} else if (name.length > 30 || surname.length >
 
30 || fatherName.length > 30 || numberContract.length >
20) {
32	alert(" Поля: Ім'я, прізвище, по-батькові не більше 30 символів");
33	return false;
34	} else if (!emailRegex.test(email)) {
35	alert("Невірний формат електронної пошти");
36	return false; 37	}
38		return true; 39	}

Б.2 Файли «registractionLogic» та «authenticationCheck»

1 @import {validateFormRegister} from '../../pages/utils/RegisterValidation.js'
2
3	export async function register(e) {
4	e.preventDefault();
5	const isValid = validateFormRegister(); 6
7	if (isValid) {
8	try {
9	await sendRequestRegister(); 10
11	} catch (error) {
12		console.error('Помилка при відправці запиту на бекенд:', error);
13	return false; 14	}
15	}
16 }
17
18	async function sendRequestRegister() {
19	let formData = new FormData(); 20
21	console.log(document.getElementById("password_r").value);
22	formData.append('userId', 1);
23	formData.append('name', document.getElementById("name_r").value);
24	formData.append('surname', document.getElementById("surname_r").value);
25	formData.append('patronymic', document.getElementById("fatherName_r").value);
26	formData.append('passwordHash', document.getElementById("password_r").value);
27	formData.append('email', document.getElementById("username_r").value);
 
28	formData.append('numberContract', document.getElementById("numberContract_r").value);
29	formData.append('photo', "");
30	formData.append('phoneNumber', document.getElementById("phoneNumber_r").value);
31	formData.append('type', "REGULAR_USER"); 32
33	let imageFile = document.getElementById("image_r").files[0];
34	formData.append('file', imageFile); 35
36	console.log(formData.values);
37	const response = await fetch('http://localhost:8080/authentication/register', {
38	method: 'POST',
39	body: formData, 40	});
41
42	if (response.ok) {
43	alert('Користувач успішно зареєстрований');
44	} else {
45		console.error('Помилка при реєстрації:', response.statusText);
46	alert("Помилка"); 47	}
48 }
49	import { TOKENS, USER } from '../../pages/utils/GlobalValue.js';
50	import {validateForm} from '../../pages/utils/Validating.js' 51
52
53	export async function signIn(e, history) {
54	e.preventDefault(); 55
56	const isValid = validateForm();
57	if (isValid) {
58	try {
59	const response = await sendRequestsignIn(); 60
61	saveInfoUser(response); 62
63	const responseTypeUser = await sendRequestUser();
64	openCorrectAccount(responseTypeUser, history); 65
66	} catch (error) {
67		console.error('Помилка при відправці запиту на бекенд:', error);
68	return false; 69	}
70	}
71 }
72
 



76




































114	const responseUser = await responseTypeUser.json(); 115
116
117	switch (responseUser.type) {
118	case 'DATABASE_ADMIN':
119	history.push('./mainForm');
120	break;
 

121		case 'REGULAR_USER':
122		history.push('./main');
123		break;
124		
125		default:
126		console.error('Unknown user type:', responseUser.type);
127		break;
128	}	
129		
130		return true;
131	}	

Б.3 Файл «FoodUser»

1	@import React, { useState, useEffect } from 'react';
2	import '../../styles/fridges.css';
3	import { v4 as uuidv4 } from 'uuid';
4	import { useTranslation } from 'react-i18next'; 5
6 function FoodUserForm() { 7
8	const { t} = useTranslation(); 9
10	const [food, setFood] = useState([]); 11
12 useEffect(() => { 13
14	/** Call the function that will receive the list of refrigerators from the server
15	and update the state of the component. */
16	fetchFood();
17	}, []); // An empty array means that the effect will be called only after the first rendering.
18
19	const fetchFood = async () => {
20	try {
21	const response = await fetch(`http://localhost:8080/user/food/${localStorage.getItem("email ")}`, {
22	method: 'GET',
23	headers: {
24	'Authorization': `Bearer
${localStorage.getItem("accessToken")}`,
25	'Content-Type': 'application/json', 26	},
27	});
28
29	if (!response.ok) {
30	throw new Error(`HTTP error! Status: ${response.status}`);
 
31	}
32
33	const data = await response.json();
34	setFood(data);
35	} catch (error) {
36	console.error('Error fetching fridges:', error.message); 37	}
38 };
39
40
41	return (
42	<div>
43	<header className="header">
44	<div className="conteiner">
45	<a href="./main" className="logo">
46	<img src="../logo.jpg" alt="logo" /> 47	</a>
48	<a href="./fridges" className="nav">
49	{t('footerUser.fridge')} 50	</a>
51	<a href="./food" className="nav">
52	{t('footerUser.food')} 53	</a>
54	<a href="./history" className="nav">
55	{t('footerUser.history')} 56	</a>
57	<a href="./autoOrder" className="nav">
58	{t('footerUser.autoOrder')} 59	</a>
60	<a href="./subscription" className="nav">
61	{t('footerUser.subscription')} 62	</a>
63	<div className="dropdown">
64	<img src="../menu.png" alt="menu" className = "menu"/>
65	<div className="dropdown-content">
66	<a
href="./settings">{t('footerUser.settings')}</a>
67	<a href="/sign-in">{t('footerUser.exist')}</a>
68	</div>
69	</div>
70	</div>
71	</header> 72
73	<div className="main-content">
74	<div className="fridges-list_l">
75	<h2>{t('footerUser.justFood')}</h2>
76	<ul>
77	{food.map((food) => (
78	<li key={uuidv4()
 
79	}><h3>Name: {food.name}, Number boxes:
{food.number_boxes},
80	Date validity: {food.date_delivery ? food.date_delivery
: 'N/A'},
81	Date transaction: {food.end_date ? food.end_date : 'N/A'},
82	ID of fridge: {food.fridge_access}</h3></li>
83	))}
84	</ul>
85	</div>
86	</div> 87
88	<footer className="footer">
89	<p style={{ fontSize: '20pt' }}>{t('bar.project')}</p>
90	<div className="contact-info">
91	<p>{t('bar.contacts')}</p>
92	<ul>
93	<li>pavlo.kokhanevych@nure.ua</li> 94	</ul>
95	</div>
96	</footer>
97	</div> 98 );
99 }
100
101	export default FoodUserForm;

Б.4 Файл «checkoutPayment»


1 @
2	export async function sendSubscription() {
3	try {
4	const currentDate = new Date();
5	const endDate = new Date();
6	endDate.setMonth(endDate.getMonth() + 6); 7
8	const user = await getUser(); 9
10	const subscriptionData = {
11	beginDate: currentDate,
12	endDate: endDate,
13	price: 19,
14	user: user, 15	};
16
17	const response = await fetch("http://localhost:8080/user/addSubscription", {
 
18	method: "POST",
19	headers: {
20	"Content-Type": "application/json",
21	Authorization: `Bearer
${localStorage.getItem("accessToken")}`, 22	},
23		body: JSON.stringify(subscriptionData), 24	});
25
26	if (response.ok) {
27	console.log('Subscription added successfully!');
28	} else {
29	console.error('Failed to add subscription.'); 30	}
31	} catch (error) {
32	console.error('Error:', error); 33	}
34 }
35
36	async function getUser() {
37	try {
38	const response = await fetch(`/user/account/${localStorage.getItem("email")}`, {
39	method: "GET",
40	headers: {
41	Authorization: `Bearer
${localStorage.getItem("accessToken")}`,
42	'Content-Type': 'application/json', 43	},
44	});
45
46	if (response.ok) {
47	const user = await response.json();
48	return user;
49	} else {
50	console.error('Failed to get user ID.');
51	return null; 52	}
53	} catch (error) {
54	console.error('Error:', error);
55	return null; 56	}
57 }
 
Б.5 Файл «autoOrderAdd»


1	p
2	export async function addOrder(productList) {
3	try {
4		const orders = productList.map((product) => {
5	return {
6		dateDelivery: new Date(),
7	number: product.count,
8	access: 1,
9	product: {
10	name: product.name,
11	weight:
product.weight, 12	},
13	};
14	});
15
16	await sendOrdersToServer(orders);
17	} catch (error) {
18	console.error('Error placing orders:', error.message);
19	}
20 }
21
22	async function sendOrdersToServer(orders) {
23	try {
24	const response = await fetch('http://localhost:8080/use r/autoOrdering/addOrder', {
25	method: 'POST',
26	headers: {
27	Authorization: `Bearer
${localStorage.getItem("accessTo ken")}`,
28	'Content-Type': 'application/json',
29	},
30	body:
JSON.stringify(orders), 31	});
32
 
33	if (!response.ok) {
34	throw new Error(`HTTP error! Status:
${response.status}`);
35	} else {
36	alert("Успішно додано!");
37	}
38
39	} catch (error) {
40	console.error('Error sending orders to server:', error.message);
41	}
42 }


Б.6 Файл «settingsSaver»


1	@	
2	export async function saveChanges(e)	{
3	e.preventDefault();	
4		
5	try {	
6	await sendRequestSave();	
7	} catch (error) {	
8		console.error('Помилка при відправці запиту на бекенд:', error);
9	return false; 10	}
11 }
12
13	async function sendRequestSave() {
14	let passwordHash = document.getElementById("password_s").value;
15	let id = document.getElementById("id_s").value;
16	let name = document.getElementById("name_s").value;
17	let surname = document.getElementById("surname_s").value;
18	let patronymic = document.getElementById("fatherName_s").value;
19	let phoneNumber = document.getElementById("phoneNumber_s").value;
20	let numberContract = document.getElementById("numberContract_s").value;
21	let email = document.getElementById("username_s").value; 22
23	const data = {
24	userId: id,
25	name,
26	surname,
 

27		patronymic,
28		passwordHash,
29		email,
30		numberContract,
31		phoneNumber,
32		type: "REGULAR_USER"
33	};	
34		
35	const response = await fetch(`http://localhost:8080/user/account/${localStorage.getItem("em ail")}/update`, {
36	method: 'POST',
37	headers: {
38	Authorization: `Bearer
${localStorage.getItem("accessToken")}`,
39	'Content-Type': 'application/json', 40	},
41		body: JSON.stringify(data), 42	});
43
44	if (response.ok) {
45	alert('Зміни прийняті');
46	} else {
47	console.error('Помилка при реєстрації:', response.statusText);
48	alert("Помилка"); 49	}
50 }
51
52	export async function getUser() {
53	try {
54	const response = await fetch(`http://localhost:8080/user/account/${localStorage.getItem("em ail")}`, {
55	method: "GET",
56	headers: {
57	Authorization: `Bearer
${localStorage.getItem("accessToken")}`,
58	'Content-Type': 'application/json', 59	},
60	});
61
62	if (response.ok) {
63	const user = await response.json();
64	return user;
65	} else {
66	console.error('Failed to get user ID.');
67	return null; 68	}
69	} catch (error)
	
